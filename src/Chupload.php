<?php


namespace BFITech\ZapChupload;

use BFITech\ZapCore\Router;
use BFITech\ZapCore\Logger;


/**
 * Chupload class.
 */
class ChunkUpload {

	/** Core instance. */
	public static $core = null;
	/** Logger instance. */
	public static $logger = null;

	// make sure these are the same with client
	private $post_prefix;
	private $chunk_size;
	private $max_filesize;

	private $with_fingerprint = false;

	private $tempdir = null;
	private $destdir = null;

	/**
	 * Constructor.
	 *
	 * @param object $core A core instance.
	 * @param string $tempdir Temporary upload directory.
	 * @param string $destdir Destination directory.
	 * @param string|null $post_prefix POST data prefix.
	 * @param int|null $chunk_size Chunk size, defaults to 2M.
	 * @param int|null $max_filesize Maximum filesize, defaults
	 *     to 10M.
	 * @param bool $with_fingerprint If true, fingerprint will
	 *     be verified by $this->check_fingerprint() after each
	 *     chunk upload is complete.
	 * @param object|null $logger An instance of logging service.
	 *     If left as null, default logger is used, implying
	 *     error level and usage of STDERR.
	 */
	public function __construct(
		Router $core, $tempdir, $destdir,
		$post_prefix=null, $chunk_size=null, $max_filesize=null,
		$with_fingerprint=false, Logger $logger=null
	) {
		self::$core = $core;

		if (!$logger)
			$logger = new Logger();
		self::$logger = $logger;

		// defaults
		$this->post_prefix = '__chupload_';
		$this->chunk_size = 1024 * 100;
		$this->max_filesize = 1024 * 1024 * 10;

		if ($post_prefix !== null)
			$this->post_prefix = (string)$post_prefix;

		$this->with_fingerprint = (bool)$with_fingerprint;

		if ($chunk_size) {
			$chunk_size = (int)$chunk_size;
			if ($chunk_size > 1024 * 1024 * 2) {
				$logger->warning(
					"Chupload: chunk size > 2M. Default 2M is used.");
				$chunk_size = null;
			} elseif ($chunk_size < 1024) {
				$logger->warning(
					"Chupload: chunk size < 1k. Default 2M is used.");
				$chunk_size = null;
			} else {
				$logger->debug(sprintf(
					"Chupload: using chunk size: %s.", $chunk_size));
			}
		}
		if ($chunk_size)
			$this->chunk_size = $chunk_size;

		if ($max_filesize) {
			$max_filesize = (int)$max_filesize;
			if ($max_filesize < $this->chunk_size) {
				$logger->warning(
					"Chupload: max filesize < chunk size. ".
					"Default 10M is used.");
			} else {
				$this->max_filesize = $max_filesize;
			}
		}

		$logger->debug(sprintf(
			"Chupload: using max filesize: %s.", $this->max_filesize));

		if (!$tempdir || !$destdir) {
			$errmsg = sprintf('%s not set.',
				(!$tempdir ? 'Temporary' : 'Destination'));
			$logger->error("Chupload: $errmsg");
			throw new ChunkUploadError($errmsg);
		}

		if ($tempdir == $destdir) {
			$errmsg = "Temp and destination dirs shan't be the same.";
			$logger->error("Chupload: $errmsg");
			throw new ChunkUploadError($errmsg);
		}

		foreach ([
			'tempdir' => $tempdir,
			'destdir' => $destdir,
		] as $dname => $dpath) {
			if (!is_dir($dpath) && !@mkdir($dpath, 0755)) {
				$errmsg = sprintf(
					"Cannot create %s directory: '%s.'",
					$dname, $dpath);
				$logger->error("Chupload: $errmsg");
				throw new ChunkUploadError($errmsg);
			}
			$this->$dname = $dpath;
		}
	}

	/**
	 * Default fingerprint check.
	 *
	 * This default method only returns true.
	 *
	 * @param string $fingerprint A fingerprint generated by client.
	 * @param string $chunk_received Received chunk.
	 * @return bool True if fingerprint matches, false otherwise.
	 *     Unmatched fingerprint will halt remaining chunk uploads.
	 * @codeCoverageIgnore
	 */
	protected function check_fingerprint($fingerprint, $chunk_received) {
		// patch this
		return true;
	}

	/**
	 * Default basename generator.
	 *
	 * @param string $path Path to a file.
	 * @codeCoverageIgnore
	 */
	protected function get_basename($path) {
		// patch this
		return basename($path);
	}

	/**
	 * Post-processing.
	 *
	 * Use this for fast post-processing such as pulling and/or
	 * stripping EXIF tags. For longer processing, hide destdir
	 * and process from there to avoid script timeout.
	 *
	 * @param string $path Path to destination path.
	 * @return bool|string False for failed post-processing, new
	 *     destination path otherwise, which can be the same with
	 *     input path. Changing path must be wrapped inside this
	 *     method.
	 * @codeCoverageIgnore
	 */
	protected function post_processing($path) {
		// patch this
		return $path;
	}

	/**
	 * Print JSON.
	 *
	 * This is different from typical core JSON since it's
	 * related to upload end status.
	 *
	 * @param int $errno Error number.
	 * @param array $data Data.
	 */
	public static function json($errno, $data) {
		$Err = new ChunkUploadError;

		$http_code = 200;
		if (in_array($errno, [
			$Err::EREQ,
			$Err::ECST,
		])) {
			$http_code = 403;
		} elseif (in_array($errno, [
			$Err::EUPL,
			$Err::EDIO,
		])) {
			$http_code = 503;
		}
		self::$core->print_json($errno, $data, $http_code);
	}

	/**
	 * Safely unlink file.
	 *
	 * @codeCoverageIgnore
	 */
	private function unlink($file) {
		if (@unlink($file))
			return true;
		self::$logger->error(sprintf(
			"Chupload: Cannot delete file: '%s'.", $file));
		return false;
		#throw new ChunkUploadError($errmsg);
	}

	/**
	 * Uploader.
	 *
	 * @param array $args ZapCore arguments.
	 */
	public function upload($args) {
		$Err = new ChunkUploadError;

		$post = $args['post'];
		$files = $args['files'];

		if (!$files || !isset($files[$this->post_prefix . 'blob'])) {
			# file field incomplete
			self::$logger->warning(
				"Chupload: chunk not received.");
			return self::json($Err::EREQ, [$Err::EREQ_NO_CHUNK]);
		}

		$keys = ['name', 'size', 'index'];
		if ($this->with_fingerprint)
			$keys[] = 'fingerprint';
		$vals = [];
		$pfx = $this->post_prefix;

		foreach($keys as $key) {
			if (!isset($post[$pfx . $key])) {
				# post field incomplete
				self::$logger->warning(sprintf(
					"Chupload: '%s' form data not received.",
					$key));
				return self::json(
					$Err::EREQ, [$Err::EREQ_DATA_INCOMPLETE]);
			}
			$vals[$key] = $post[$pfx . $key];
		}
		extract($vals, EXTR_SKIP);

		$size = intval($size);
		if ($size < 1) {
			# size violation
			self::$logger->warning("Chupload: invalid filesize.");
			return self::json($Err::ECST, [$Err::ECST_FSZ_INVALID]);
		}
		$index = intval($index);
		if ($index < 0) {
			# index undersized
			self::$logger->warning("Chupload: invalid chunk index.");
			return self::json(
				$Err::ECST, [$Err::ECST_CID_UNDERSIZED]);
		}
		$max_chunk = floor($size / $this->chunk_size);

		if ($size > $this->max_filesize) {
			# max size violation
			self::$logger->warning(
				"Chupload: max filesize violation.");
			return self::json($Err::ECST, [$Err::ECST_FSZ_OVERSIZED]);
		}
		if ($index * $this->chunk_size > $this->max_filesize) {
			# index oversized
			self::$logger->warning(
				"Chupload: chunk index violation.");
			return self::json($Err::ECST, [$Err::ECST_CID_OVERSIZED]);
		}

		$blob = $args['files'][$pfx . 'blob'];
		if ($blob['error'] !== 0) {
			# generic upload error
			self::$logger->error(sprintf(
				"Chupload: upload error: %s.", $blob['error']));
			return self::json($Err::EUPL, [$blob['error']]);
		}

		$chunk_path = $blob['tmp_name'];
		if (filesize($chunk_path) > $this->chunk_size) {
			# chunk oversized
			self::$logger->warning(
				"Chupload: invalid chunk index.");
			$this->unlink($chunk_path);
			return self::json($Err::ECST, [$Err::ECST_MCH_OVERSIZED]);
		}

		$chunk = file_get_contents($chunk_path);

		$basename = $this->get_basename($name);
		$tempname = $this->tempdir . '/' . $basename;
		$destname = $this->destdir . '/' . $basename;

		# always overwrite old file with the same name, hence
		# make sure get_basename() guarantee uniqueness
		// @codeCoverageIgnoreStart
		if (file_exists($destname) && !$this->unlink($destname))
			return self::json($Err::EDIO, []);
		// @codeCoverageIgnoreEnd

		// pack chunk
		# truncate or append
		if (false === $fn = @fopen(
			$tempname, ($index === 0 ? 'wb' : 'ab'))
		) {
			// @codeCoverageIgnoreStart
			$errmsg = sprintf(
				"Cannot open temp file: '%s'.", $tempname);
			self::$logger->error("Chupload: $errmsg");
			return self::json($Err::EDIO, []);
			// @codeCoverageIgnoreEnd
		}
		# write to temp blob
		fwrite($fn, $chunk);
		# append index
		if ($index < $max_chunk)
			fwrite($fn, pack('v', $index));
		fclose($fn);
		# remove chunk
		$this->unlink($chunk_path);

		// fingerprint check
		if (
			$this->with_fingerprint &&
			!$this->check_fingerprint($fingerprint, $chunk)
		) {
			# fingerprint violation
			self::$logger->warning(
				"Chupload: fingerprint doesn't match.");
			$this->unlink($tempname);
			return self::json($Err::ECST, [$Err::ECST_FGP_INVALID]);
		}

		// merge chunks on finish
		if ($max_chunk == $index) {
			$merge_status = $this->merge_chunks(
				$tempname, $destname, $max_chunk);
			if ($merge_status !== 0) {
				$this->unlink($destname);
				$this->unlink($tempname);
				self::$logger->warning("Chupload: broken chunk.");
				return self::json($merge_status[0], $merge_status[1]);
			}
			$this->unlink($tempname);
			$destname = $this->post_processing($destname);
			if (!$destname) {
				self::$logger->error(
					"Chupload: post-processing failed.");
				return self::json(
					$Err::ECST, [$Err::ECST_POSTPROC_FAIL]);
			}
		}

		// success
		self::$logger->info(
			"Chupload: file successfully uploaded: '$basename'.");
		return self::$core->print_json(0, [
			'path' => $basename,
			'index'  => $index,
		]);
	}

	private function merge_chunks($tempname, $destname, $max_chunk) {
		$Err = new ChunkUploadError;
		if (
			false === ($hi = @fopen($tempname, 'rb')) ||
			false === ($ho = @fopen($destname, 'wb'))
		) {
			// @codeCoverageIgnoreStart
			$errmsg = sprintf(
				"Cannot open files for merging: '%s' -> '%s'.",
				$tempname, $destname);
			self::$logger->error("Chupload: $errmsg");
			return [$Err::EDIO, []];
			// @codeCoverageIgnoreEnd
		}
		if ($max_chunk == 0) {
			# single or last chunk
			$chunk = fread($hi, $this->chunk_size);
			if (filesize($tempname) > $this->chunk_size)
				return [$Err::ECST, [$Err::ECST_MCH_OVERSIZED]];
			fwrite($ho, $chunk);
			return 0;
		}
		$total = 0;
		for ($i=0; $i<$max_chunk; $i++) {
			$chunk = fread($hi, $this->chunk_size);
			$total += $this->chunk_size;
			if ($total > $this->max_filesize)
				return [$Err::ECST, [$Err::ECST_FSZ_INVALID]];
			fwrite($ho, $chunk);
			$tail = fread($hi, 2);
			if (strlen($tail) < 2)
				return [$Err::ECST, [$Err::ECST_MCH_UNORDERED]];
			$i_unpack = unpack('vint', $tail)['int'];
			if ($i !== $i_unpack)
				return [$Err::ECST, [$Err::ECST_MCH_UNORDERED]];
		}
		return 0;
	}

	/**
	 * Retrieve private post_prefix property.
	 */
	public function get_post_prefix() {
		return $this->post_prefix;
	}

	/**
	 * Retrieve private chunk_size property.
	 */
	public function get_chunk_size() {
		return $this->chunk_size;
	}

	/**
	 * Retrieve private max_filesize property.
	 */
	public function get_max_filesize() {
		return $this->max_filesize;
	}

}

